{
  "hash": "ca0b5ab9853e934666107b1d6bb2246e",
  "result": {
    "markdown": "---\ntitle: 'BowedString Part 2: Bow Table'\ndate: '2023-09-16'\nformat:\n  html:\n    code-fold: true\n    code-summary: Show the code\n---\n\nNow that we have our working waveguide, we need something to excite it. This is done with the help of\na [bow table](https://ccrma.stanford.edu/~jos/BowedStrings/Simplified_Piecewise_Linear_Bow.html). While the linear bow table would be simple to implement, we would need to know the capture or break-away differential velocity value $v_\\Delta^c$ and also how this value responds to varying force values. I could not find a simple way to find these values but luckily, the [STK](https://github.com/thestk/stk) library has a bow table that we can reuse.\n\nLet's take a look at the bow table as defined in the [stk](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/include/BowTable.h#L84):\n\n$$ BowTable(v_\\Delta^+) = \\min \\left \\{(|v_\\Delta^+|*Slope + 0.75)^{-4}, 1 \\right \\} $$\n\nWhere $v_\\Delta^+$ is the velocity of the bow minus the velocity of the string going into the bow and $Slope$ is the parameter that controls the shape of the table and is related to the bow force. While the equation may seem daunting at first, we can easily plot it and immediately recognize a shape similar to the linear bow table as presented by figure [9.54](https://ccrma.stanford.edu/~jos/pasp/Bow_String_Scattering_Junction.html) in Physical Audio Signal Processing by Julius O. Smith.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n\nv_delta = np.linspace(-1, 1, 50)\nbow_force = 4\n\noutput = np.minimum(pow(abs(v_delta) * bow_force + 0.75, -4), 1)\n\nplt.figure(1)\nplt.plot(v_delta, output)\nplt.xlabel('$v_\\Delta^+$')\nplt.ylabel('Reflection Coefficient')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n<>:12: SyntaxWarning: invalid escape sequence '\\D'\n<>:12: SyntaxWarning: invalid escape sequence '\\D'\nC:\\Users\\Alex\\AppData\\Local\\Temp\\ipykernel_42584\\4158656264.py:12: SyntaxWarning: invalid escape sequence '\\D'\n  plt.xlabel('$v_\\Delta^+$')\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-2-output-2.png){width=589 height=434 fig-alt='A graph showing the bow table as defined in the stk'}\n:::\n:::\n\n\nWe can now observe how varying the force transforms the bow table.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nv_delta = np.linspace(-1, 1, 100)\n\nplt.figure(2)\nfor f in [1, 2.5, 5]:\n    output = np.minimum(pow(abs(v_delta) * f + 0.75, -4), 1)\n    plt.plot(v_delta, output, label=f'force={f}')\nplt.legend()\nplt.xlabel('$v_\\\\Delta^+$')\nplt.ylabel('Reflection Coefficient')\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-3-output-1.png){width=589 height=434}\n:::\n:::\n\n\nAs $Slope$ goes up, the region of the table where the reflection coefficient is 1 gets smaller. This plateau represents the moment where the bow and the string are \"sticking\" together.\n\nWe now need to find what is the usable range for $Slope$. Looking at the STK again, we can see where the slope is set:\n\n[bowed.cpp](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/src/Bowed.cpp#L155)\n```{c++}\n    bowTable_.setSlope( 5.0 - (4.0 * normalizedValue) );\n```\n\nWhere `normalizedValue` is a value between 0 and 1 representing the bow pressure. This effectively restricts the slope value between 1 and 5. In other words, as the bow pressure increases, the 'sticking' zone of the bow table gets larger. We can plot the bow table equation again, but this time with varying force values between 0 and 10 to understand why.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nv_delta = np.linspace(-1, 1, 50)\nf_bow = np.linspace(0, 10, 50)\n\nv_delta, f_bow = np.meshgrid(v_delta, f_bow)\noutput = np.minimum(pow(abs(v_delta) * f_bow + 0.75, -4), 1)\n\nfig, ax = plt.subplots()\nsurf = ax.pcolormesh(\n    f_bow,\n    v_delta,\n    output,\n    linewidth=0,\n    cmap='viridis',)\n\nfig.colorbar(surf, shrink=0.5, aspect=5, label='Reflection Coefficient')\n\nax.yaxis.set_major_formatter('{x:.02f}')\nax.xaxis.set_major_locator(MultipleLocator(1))\nax.set_xlabel('$Slope$')\nax.set_ylabel('$v_\\\\Delta^+$')\nax.dist = 10\n```\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-4-output-1.png){width=614 height=433}\n:::\n:::\n\n\nLooking at the graph, we can immediately see that once the slope gets higher than 5, the reflection coefficient returned by the table stays consistent and there's limited value for a bow table to support a slope value higher than 5. On the other hand, with a slope value $<1$, the table becomes almost flat.\n\n",
    "supporting": [
      "bow_table_files"
    ],
    "filters": [],
    "includes": {}
  }
}