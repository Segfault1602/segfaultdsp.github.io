{
  "hash": "9042b11ff2552af942d8e22a86903cf2",
  "result": {
    "markdown": "---\ntitle: Bow Table\nauthor: Alexandre St-Onge\ndate: '2023-09-16'\n---\n\nLet's take a look at the bow table as defined in the [stk](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/include/BowTable.h#L84):\n\n$$ BowTable(v_\\Delta^+) = \\min \\left \\{(|v_\\Delta^+|*f_{bow} + 0.75)^{-4}, 1 \\right \\} $$\n\nWhere $v_\\Delta^+$ is the velocity of the bow minus the velocity of the string going into the bow and $f_{bow}$ is the bow force. While the equation may seem daunting at first, we can easily plot it and immediatly recognize a shape similar to the linear bow table as presented by figure [9.54](https://ccrma.stanford.edu/~jos/pasp/Bow_String_Scattering_Junction.html) in Physical Audio Signal Processing by Julius O. Smith.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n\nv_delta = np.linspace(-1, 1, 50)\nbow_force = 4\n\noutput = np.minimum(pow(abs(v_delta) * bow_force + 0.75, -4), 1)\n\nplt.figure(1)\nplt.plot(v_delta, output)\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-2-output-1.png){width=571 height=411}\n:::\n:::\n\n\nWe can now observe how varying the force transform bow table.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nv_delta = np.linspace(-1, 1, 100)\n\nplt.figure(2)\nfor f in [1, 2.5, 5]:\n    output = np.minimum(pow(abs(v_delta) * f + 0.75, -4), 1)\n    plt.plot(v_delta, output, label=f'force={f}')\nplt.legend()\nplt.grid()\n```\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-3-output-1.png){width=571 height=411}\n:::\n:::\n\n\nSee how as the \"force\" goes up, the region of the table where the reflection coefficient is 1 gets smaller. This is simply a quirk of the equation we are using as in reality, the more force is applied, the easier it will be for the string and bow to stick toghether. It is common to control parameter like these by assigning a value going from 0 to 1, which make this a little bit counterintuitive, but this is something that we will address later.\n\nFor now, let's try to find a usable range of value for $f_{bow}$. To do so we can plot the same graph as before and adding $f_{bow}$ as a variable.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nv_delta = np.linspace(-1, 1, 50)\nf_bow = np.linspace(0, 10, 50)\n\nv_delta, f_bow = np.meshgrid(v_delta, f_bow)\noutput = np.minimum(pow(abs(v_delta) * f_bow + 0.75, -4), 1)\n\nfig, ax = plt.subplots()\nsurf = ax.pcolormesh(\n    f_bow,\n    v_delta,\n    output,\n    linewidth=0,\n    cmap='viridis',)\n\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nax.yaxis.set_major_formatter('{x:.02f}')\nax.xaxis.set_major_locator(MultipleLocator(1))\nax.set_xlabel('Bow Force')\nax.set_ylabel('v_delta')\nax.dist = 10\n```\n\n::: {.cell-output .cell-output-display}\n![](bow_table_files/figure-html/cell-4-output-1.png){width=591 height=431}\n:::\n:::\n\n\nLooking at the graph, we can immediatly see that once the bow force gets higher than 5, the reflection coefficient returned by the table stays consistent and there's limited value for a bow table to support force value higher than 5. On the other hand, with a bow force value near 0, the table will always return a reflection coefficient of 1. From this, we can conclude that we will probably want to limit our bow force value between 1 and 5. And if we look at [bowed.cpp](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/src/Bowed.cpp#L155) we can see this equation:\n\n```{c++}\n    bowTable_.setSlope( 5.0 - (4.0 * normalizedValue) );\n```\n\nWhere `normalizedValue` is a value between 0 and 1. This equation solves our two problems:\n1. It limits the bow force value between 1 and 5\n2. An increasing `normalizedValue` now correspond to a higher bow force.\n\n",
    "supporting": [
      "bow_table_files"
    ],
    "filters": [],
    "includes": {}
  }
}