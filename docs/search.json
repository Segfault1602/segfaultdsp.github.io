[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Segfault DSP",
    "section": "",
    "text": "Welcome to my personal page!"
  },
  {
    "objectID": "index.html#softwares",
    "href": "index.html#softwares",
    "title": "Segfault DSP",
    "section": "Softwares",
    "text": "Softwares\n\nlibdsp: Simple C++ audio dsp library.\nBowedVst Polyphonic bowed string VST using JUCE.\nLinnLED Python scripts used to configure the LED on the Linnstrument to match microtonal scales."
  },
  {
    "objectID": "index.html#articles",
    "href": "index.html#articles",
    "title": "Segfault DSP",
    "section": "Articles",
    "text": "Articles"
  },
  {
    "objectID": "posts/bow_table/bow_table.html",
    "href": "posts/bow_table/bow_table.html",
    "title": "Bow Table",
    "section": "",
    "text": "Let’s take a look at the bow table as defined in the stk:\n\\[ BowTable(v_\\Delta^+) = \\min \\left \\{(|v_\\Delta^+|*f_{bow} + 0.75)^{-4}, 1 \\right \\} \\]\nWhere \\(v_\\Delta^+\\) is the velocity of the bow minus the velocity of the string going into the bow and \\(f_{bow}\\) is the bow force. While the equation may seem daunting at first, we can easily plot it and immediatly recognize a shape similar to the linear bow table as presented by figure 9.54 in Physical Audio Signal Processing by Julius O. Smith.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n\nv_delta = np.linspace(-1, 1, 50)\nbow_force = 4\n\noutput = np.minimum(pow(abs(v_delta) * bow_force + 0.75, -4), 1)\n\nplt.figure(1)\nplt.plot(v_delta, output)\nplt.grid()\n\n\n\n\nWe can now observe how varying the force transform bow table.\n\nv_delta = np.linspace(-1, 1, 100)\n\nplt.figure(2)\nfor f in [1, 2.5, 5]:\n    output = np.minimum(pow(abs(v_delta) * f + 0.75, -4), 1)\n    plt.plot(v_delta, output, label=f'force={f}')\nplt.legend()\nplt.grid()\n\n\n\n\nSee how as the “force” goes up, the region of the table where the reflection coefficient is 1 gets smaller. This is simply a quirk of the equation we are using as in reality, the more force is applied, the easier it will be for the string and bow to stick toghether. It is common to control parameter like these by assigning a value going from 0 to 1, which make this a little bit counterintuitive, but this is something that we will address later.\nFor now, let’s try to find a usable range of value for \\(f_{bow}\\). To do so we can plot the same graph as before and adding \\(f_{bow}\\) as a variable.\n\nv_delta = np.linspace(-1, 1, 50)\nf_bow = np.linspace(0, 10, 50)\n\nv_delta, f_bow = np.meshgrid(v_delta, f_bow)\noutput = np.minimum(pow(abs(v_delta) * f_bow + 0.75, -4), 1)\n\nfig, ax = plt.subplots()\nsurf = ax.pcolormesh(\n    f_bow,\n    v_delta,\n    output,\n    linewidth=0,\n    cmap='viridis',)\n\nfig.colorbar(surf, shrink=0.5, aspect=5)\n\nax.yaxis.set_major_formatter('{x:.02f}')\nax.xaxis.set_major_locator(MultipleLocator(1))\nax.set_xlabel('Bow Force')\nax.set_ylabel('v_delta')\nax.dist = 10\n\n\n\n\nLooking at the graph, we can immediatly see that once the bow force gets higher than 5, the reflection coefficient returned by the table stays consistent and there’s limited value for a bow table to support force value higher than 5. On the other hand, with a bow force value near 0, the table will always return a reflection coefficient of 1. From this, we can conclude that we will probably want to limit our bow force value between 1 and 5. And if we look at bowed.cpp we can see this equation:\n    bowTable_.setSlope( 5.0 - (4.0 * normalizedValue) );\nWhere normalizedValue is a value between 0 and 1. This equation solves our two problems: 1. It limits the bow force value between 1 and 5 2. An increasing normalizedValue now correspond to a higher bow force."
  },
  {
    "objectID": "posts/windowed_sinc/windowed_sinc.html",
    "href": "posts/windowed_sinc/windowed_sinc.html",
    "title": "Windowed sinc resampling",
    "section": "",
    "text": "First, let’s get out python imports out of the way.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.special import sinc\nfrom scipy.signal.windows import kaiser\nfrom scipy import signal\nfrom math import ceil\n\nLet’s define a function that will build our sinc table for us. The sinc table will only contain the “right wing” of the symmetric FIR filter. This function will also return a table of differences between successive FIR sample which will be useful to speed up our linear interpolation latter on.\n\ndef build_sinc_table(num_zeros, samples_per_crossing):\n\n    SINC_SIZE_ = num_zeros * samples_per_crossing\n    KAISER_BETA = 10\n\n    x = np.linspace(-num_zeros, num_zeros, SINC_SIZE_ * 2 + 1)\n    y = sinc(x)\n\n    window = kaiser(len(y), KAISER_BETA)\n\n    y = np.multiply(y, window)\n\n    h = y[SINC_SIZE_:]\n\n    h_diff = np.subtract(h[1:], h[:-1])\n    h_diff = np.append(h_diff, 0)\n\n    return h, h_diff\n\nAnd here’s what our table looks like:\n\nh, h_diff = build_sinc_table(num_zeros=13, samples_per_crossing=512)\nplt.figure(1)\nplt.plot(h)\nplt.grid()\n\n\n\n\nWe can now implement the main algorithm as described here.\n\ndef sinc_resample(x, ratio, h, h_diff, samples_per_crossing):\n    time_step = 1 / ratio\n    filter_scale = min(1, ratio)\n    filter_step = samples_per_crossing * filter_scale\n\n    output = np.ndarray(shape=ceil(len(x) * ratio))\n    out_idx = 0\n    t = 0\n    while t &lt; len(x):\n\n        acc = 0\n\n        integer_part = int(t)\n        fractional_part = t - integer_part\n\n        # Compute left wing\n        filter_offset = filter_step * fractional_part\n\n        left_coeff_count = int((len(h) - filter_offset) / filter_step)\n        left_coeff_count = min(integer_part, left_coeff_count) # avoid underflow access\n        for i in range(-left_coeff_count, 1):\n            filter_idx = filter_offset + filter_step * abs(i)\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + i] * weight\n\n        # compute right wing\n        fractional_part = 1 - fractional_part\n        filter_offset = filter_step * fractional_part\n\n        right_coeff_count = int((len(h) - filter_offset) / filter_step)\n        right_coeff_count = min(len(x) - integer_part - 1, right_coeff_count) # avoid overflow access\n        for i in range(0, right_coeff_count):\n            filter_idx = filter_offset + filter_step * i\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + 1 + i] * weight\n\n        if out_idx &lt; len(output):\n            output[out_idx] = acc\n            out_idx += 1\n        t += time_step\n\n    return output\n\nHere’s an example of the implementation at work where we will upsample a simple sine wave. The blue dotted line on the graph effectively shows what we would have obtained using a linear interpolation method instead.\n\n# Number of zeros crossing\nNZ = 13\n\n# Number of samples per zero crossing.\n# Higher sample count means better precision for our interpolation at the cost of more memory usage.\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(NZ, SAMPLES_PER_CROSSING)\n\nORIGINAL_FS = 100\nSIGNAL_FREQUENCY = 20\nTARGET_FS = 1000\n\ntime = np.linspace(0, 1, ORIGINAL_FS)\nin_sine = np.sin(2 * np.pi * time * SIGNAL_FREQUENCY)\n\noutput = sinc_resample(in_sine, TARGET_FS / ORIGINAL_FS, h, h_diff, SAMPLES_PER_CROSSING)\nout_time = np.linspace(0, 1, TARGET_FS)\nplt.plot(out_time, output, 'g', label=\"Resampled output\")\nplt.plot(time, in_sine, 'b+:', label=\"Original signal\")\nplt.xlim(0.2, 0.4)\nplt.ylim(-1.1, 1.1)\nplt.grid()\nplt.legend(loc=\"upper right\")\nplt.show()\n\n\n\n\nWe are now ready to perform our own benchmark test. Inspired by the Infinite Wave methodology, we will try to downsample a quadratic chirp signal from 96kHz to 44.1kHz.\n\nORIGINAL_FS = 96000\nCHIRP_LENGTH_SECONDS = 8\nEND_CHIRP_FREQUENCY = 44000\n\ntime = np.linspace(0, CHIRP_LENGTH_SECONDS, ORIGINAL_FS*CHIRP_LENGTH_SECONDS)\nin_chirp = signal.chirp(time, 0, CHIRP_LENGTH_SECONDS, END_CHIRP_FREQUENCY, 'quadratic') * 0.6\n\nWe will now resample that signal 3 different ways. First, we’ll use our sinc_resample method with a sinc table containing 13 zero crossing and then again with a table containing 32 zero crossing. This should allow us to see how the number of zero crossing in our table affects the lowpass filtering of our implementation. Lastly, we will use numpy to resample the signal using linear interpolation so that we can compare our algorithm against a fast a common resampling method.\n\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_sinc_1 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_sinc_2 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nout_time = np.linspace(0, CHIRP_LENGTH_SECONDS, TARGET_FS*CHIRP_LENGTH_SECONDS)\nout_linear = np.interp(out_time, time, in_chirp)\n\ndef plot_spectrogram(title, w, fs, ax = None):\n    if ax is None:\n        fig, ax = plt.subplots()\n    plt.specgram(w, Fs=fs, mode='magnitude')\n    ax.set_title(title)\n    ax.set_xlabel('t (sec)')\n    ax.set_ylabel('Frequency (Hz)')\n    ax.set_ylim(0, ORIGINAL_FS/2)\n    ax.grid(True)\n\nfig = plt.figure(1)\nax1 = plt.subplot(221)\nplot_spectrogram(f\"Original {ORIGINAL_FS} Hz\", in_chirp, ORIGINAL_FS, ax1)\nax2 = plt.subplot(222)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_1} zeros\", out_sinc_1, TARGET_FS, ax2)\nax2 = plt.subplot(223)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_2} zeros\", out_sinc_2, TARGET_FS, ax2)\nax3 = plt.subplot(224)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz (numpy.interp)\", out_linear, TARGET_FS, ax3)\nfig.tight_layout(pad=1.0)\nplt.show()\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/axes/_axes.py:7775: RuntimeWarning: divide by zero encountered in log10\n  Z = 20. * np.log10(spec)\n\n\n\n\n\nFirst, we can immediatly notice the the resampled output lost all content above the Nyquist frequency. This explain why half the spectrogram is empty. The downward line(s) around the 6 second mark is actually the higher frequency content present in the original file that are now folding around Nyqist. This is called aliasing. We can also see how the resampling done with 32 zeros show slightly less aliasing then the 13 zeros resampling.\nLet’s look at the impulse response of our resampler.\n\nORIGINAL_FS = 96000\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nIMPULSE_LENGTH = 128\nimpulse = np.zeros(IMPULSE_LENGTH)\nimpulse[round(IMPULSE_LENGTH/2)] = 1\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_imp_1 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_imp_2 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nfig = plt.figure(2)\nfig.set_figwidth(10)\nplt.subplot(211)\nplt.plot(out_imp_1)\n\nplt.subplot(212)\nplt.plot(out_imp_2)\n\n\n\n\n\nfrom scipy import fft\n\nNFFT = 1024\nimpulse_fft = fft.fft(out_imp_1, NFFT)\nimpulse_fft = fft.fftshift(impulse_fft)\n\nfft_db = 20 * np.log10(np.abs(impulse_fft))\nxf = fft.fftfreq(NFFT, 1/TARGET_FS)\nxf = fft.fftshift(xf)\nplt.figure(3)\nplt.plot(xf, fft_db)\nplt.xlim(0, TARGET_FS)\nplt.grid()\n\n# Ideal filter\nideal_x = np.zeros(22000)\nideal_x[-1] = -10\nplt.plot(ideal_x)"
  },
  {
    "objectID": "posts/bowed_string_example/bowed_string_example.html",
    "href": "posts/bowed_string_example/bowed_string_example.html",
    "title": "BowedString audio example",
    "section": "",
    "text": "Here’s a few audio examples of the BowedString instrument. This is the output of the string without going through the body filter.\n\nVelocity and Force sweep from 0 to 1 then back to 0\n\n\n\n\n\n\n\n\nFast bowing by modulating velocity with a clipped sine wave. A staccato sound can be achieved by reducing the amount of clipping.\n\n\n\n\n\n\n\n\nVibrato\n\n\n\n\n\n\n\n\nPitch slide, 440Hz to 660Hz"
  }
]