[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "doc",
    "section": "",
    "text": "Hi\n\n\n\n\n\n\n\n\n  \n\n\n\n\nWindowed sinc resampling\n\n\n\n\n\n\n\n\n\n\n\n\nSep 16, 2023\n\n\nAlexandre St-Onge\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/windowed_sinc.html",
    "href": "posts/windowed_sinc.html",
    "title": "Windowed sinc resampling",
    "section": "",
    "text": "First, let’s get out python imports out of the way.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.special import sinc\nfrom scipy.signal.windows import kaiser\nfrom scipy import signal\nfrom math import ceil\n\nLet’s define a function that will build our sinc table for us. The sinc table will only contain the “right wing” of the symmetric FIR filter. This function will also return a table of differences between successive FIR sample which will be useful to speed up our linear interpolation latter on.\n\ndef build_sinc_table(num_zeros, samples_per_crossing):\n\n    SINC_SIZE_ = num_zeros * samples_per_crossing\n    KAISER_BETA = 10\n\n    x = np.linspace(-num_zeros, num_zeros, SINC_SIZE_ * 2 + 1)\n    y = sinc(x)\n\n    window = kaiser(len(y), KAISER_BETA)\n\n    y = np.multiply(y, window)\n\n    h = y[SINC_SIZE_:]\n\n    h_diff = np.subtract(h[1:], h[:-1])\n    h_diff = np.append(h_diff, 0)\n\n    return h, h_diff\n\nAnd here’s what our table looks like:\n\nh, h_diff = build_sinc_table(num_zeros=13, samples_per_crossing=512)\nplt.figure(1)\nplt.plot(h)\nplt.grid()\n\n\n\n\nWe can now implement the main algorithm as described here.\n\ndef sinc_resample(x, ratio, h, h_diff, samples_per_crossing):\n    time_step = 1 / ratio\n    filter_scale = min(1, ratio)\n    filter_step = samples_per_crossing * filter_scale\n\n    output = np.ndarray(shape=ceil(len(x) * ratio))\n    out_idx = 0\n    t = 0\n    while t &lt; len(x):\n\n        acc = 0\n\n        integer_part = int(t)\n        fractional_part = t - integer_part\n\n        # Compute left wing\n        filter_offset = filter_step * fractional_part\n\n        left_coeff_count = int((len(h) - filter_offset) / filter_step)\n        left_coeff_count = min(integer_part, left_coeff_count) # avoid underflow access\n        for i in range(-left_coeff_count, 1):\n            filter_idx = filter_offset + filter_step * abs(i)\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + i] * weight\n\n        # compute right wing\n        fractional_part = 1 - fractional_part\n        filter_offset = filter_step * fractional_part\n\n        right_coeff_count = int((len(h) - filter_offset) / filter_step)\n        right_coeff_count = min(len(x) - integer_part - 1, right_coeff_count) # avoid overflow access\n        for i in range(0, right_coeff_count):\n            filter_idx = filter_offset + filter_step * i\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + 1 + i] * weight\n\n        if out_idx &lt; len(output):\n            output[out_idx] = acc\n            out_idx += 1\n        t += time_step\n\n    return output\n\nHere’s an example of the implementation at work where we will upsample a simple sine wave. The blue dotted line on the graph effectively shows what we would have obtained using a linear interpolation method instead.\n\n# Number of zeros crossing\nNZ = 13\n\n# Number of samples per zero crossing.\n# Higher sample count means better precision for our interpolation at the cost of more memory usage.\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(NZ, SAMPLES_PER_CROSSING)\n\nORIGINAL_FS = 100\nSIGNAL_FREQUENCY = 20\nTARGET_FS = 1000\n\ntime = np.linspace(0, 1, ORIGINAL_FS)\nin_sine = np.sin(2 * np.pi * time * SIGNAL_FREQUENCY)\n\noutput = sinc_resample(in_sine, TARGET_FS / ORIGINAL_FS, h, h_diff, SAMPLES_PER_CROSSING)\nout_time = np.linspace(0, 1, TARGET_FS)\nplt.plot(out_time, output, 'g', label=\"Resampled output\")\nplt.plot(time, in_sine, 'b+:', label=\"Original signal\")\nplt.xlim(0.2, 0.4)\nplt.ylim(-1.1, 1.1)\nplt.grid()\nplt.legend(loc=\"upper right\")\nplt.show()\n\n\n\n\nWe are now ready to perform our own benchmark test. Inspired by the Infinite Wave methodology, we will try to downsample a quadratic chirp signal from 96kHz to 44.1kHz.\n\nORIGINAL_FS = 96000\nCHIRP_LENGTH_SECONDS = 8\nEND_CHIRP_FREQUENCY = 44000\n\ntime = np.linspace(0, CHIRP_LENGTH_SECONDS, ORIGINAL_FS*CHIRP_LENGTH_SECONDS)\nin_chirp = signal.chirp(time, 0, CHIRP_LENGTH_SECONDS, END_CHIRP_FREQUENCY, 'quadratic') * 0.6\n\nWe will now resample that signal 3 different ways. First, we’ll use our sinc_resample method with a sinc table containing 13 zero crossing and then again with a table containing 32 zero crossing. This should allow us to see how the number of zero crossing in our table affects the lowpass filtering of our implementation. Lastly, we will use numpy to resample the signal using linear interpolation so that we can compare our algorithm against a fast a common resampling method.\n\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_sinc_1 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_sinc_2 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nout_time = np.linspace(0, CHIRP_LENGTH_SECONDS, TARGET_FS*CHIRP_LENGTH_SECONDS)\nout_linear = np.interp(out_time, time, in_chirp)\n\ndef plot_spectrogram(title, w, fs, ax = None):\n    if ax is None:\n        fig, ax = plt.subplots()\n    plt.specgram(w, Fs=fs, mode='magnitude')\n    ax.set_title(title)\n    ax.set_xlabel('t (sec)')\n    ax.set_ylabel('Frequency (Hz)')\n    ax.set_ylim(0, ORIGINAL_FS/2)\n    ax.grid(True)\n\nfig = plt.figure(1)\nax1 = plt.subplot(221)\nplot_spectrogram(f\"Original {ORIGINAL_FS} Hz\", in_chirp, ORIGINAL_FS, ax1)\nax2 = plt.subplot(222)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_1} zeros\", out_sinc_1, TARGET_FS, ax2)\nax2 = plt.subplot(223)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_2} zeros\", out_sinc_2, TARGET_FS, ax2)\nax3 = plt.subplot(224)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz (numpy.interp)\", out_linear, TARGET_FS, ax3)\nfig.tight_layout(pad=1.0)\nplt.show()\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/axes/_axes.py:7775: RuntimeWarning: divide by zero encountered in log10\n  Z = 20. * np.log10(spec)\n\n\n\n\n\nFirst, we can immediatly notice the the resampled output lost all content above the Nyquist frequency. This explain why half the spectrogram is empty. The downward line(s) around the 6 second mark is actually the higher frequency content present in the original file that are now folding around Nyqist. This is called aliasing. We can also see how the resampling done with 32 zeros show slightly less aliasing then the 13 zeros resampling.\nLet’s look at the impulse response of our resampler.\n\nORIGINAL_FS = 96000\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nIMPULSE_LENGTH = 128\nimpulse = np.zeros(IMPULSE_LENGTH)\nimpulse[round(IMPULSE_LENGTH/2)] = 1\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_imp_1 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_imp_2 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nfig = plt.figure(2)\nfig.set_figwidth(10)\nplt.subplot(211)\nplt.plot(out_imp_1)\n\nplt.subplot(212)\nplt.plot(out_imp_2)\n\n\n\n\n\nfrom scipy import fft\n\nNFFT = 1024\nimpulse_fft = fft.fft(out_imp_1, NFFT)\nimpulse_fft = fft.fftshift(impulse_fft)\n\nfft_db = 20 * np.log10(np.abs(impulse_fft))\nxf = fft.fftfreq(NFFT, 1/TARGET_FS)\nxf = fft.fftshift(xf)\nplt.figure(3)\nplt.plot(xf, fft_db)\nplt.xlim(0, TARGET_FS)\nplt.grid()\n\n# Ideal filter\nideal_x = np.zeros(22000)\nideal_x[-1] = -10\nplt.plot(ideal_x)"
  }
]