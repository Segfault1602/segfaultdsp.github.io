[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Segfault DSP",
    "section": "",
    "text": "Welcome to my personal page!"
  },
  {
    "objectID": "index.html#softwares",
    "href": "index.html#softwares",
    "title": "Segfault DSP",
    "section": "Softwares",
    "text": "Softwares\n\nlibdsp: Simple C++ audio dsp library.\nBowedVst Polyphonic bowed string VST using JUCE.\nLinnLED Python scripts used to configure the LED on the Linnstrument to match microtonal scales."
  },
  {
    "objectID": "index.html#articles",
    "href": "index.html#articles",
    "title": "Segfault DSP",
    "section": "Articles",
    "text": "Articles"
  },
  {
    "objectID": "posts/bowed_string/bow_table.html",
    "href": "posts/bowed_string/bow_table.html",
    "title": "BowedString Part 2: Bow Table",
    "section": "",
    "text": "Now that we have our working waveguide, we need something to excite it. This is done with the help of a bow table. While the linear bow table would be simple to implement, we would need to know the capture or break-away differential velocity value \\(v_\\Delta^c\\) and also how this value responds to varying force values. I could not find a simple way to find these values but luckily, the STK library has a bow table that we can reuse.\nLet’s take a look at the bow table as defined in the stk:\n\\[ BowTable(v_\\Delta^+) = \\min \\left \\{(|v_\\Delta^+|*Slope + 0.75)^{-4}, 1 \\right \\} \\]\nWhere \\(v_\\Delta^+\\) is the velocity of the bow minus the velocity of the string going into the bow and \\(Slope\\) is the parameter that controls the shape of the table and is related to the bow force. While the equation may seem daunting at first, we can easily plot it and immediately recognize a shape similar to the linear bow table as presented by figure 9.54 in Physical Audio Signal Processing by Julius O. Smith.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n\nv_delta = np.linspace(-1, 1, 50)\nslope = 4\n\noutput = np.minimum(pow(abs(v_delta) * slope + 0.75, -4), 1)\n\nplt.figure(1)\nplt.plot(v_delta, output)\nplt.xlabel('$v_\\Delta^+$')\nplt.ylabel('Reflection Coefficient')\nplt.grid()\n\n\n\n\n\nWe can now observe how varying the force transforms the bow table.\n\n\nCode\nv_delta = np.linspace(-1, 1, 100)\n\nplt.figure(2)\nfor f in [1, 2.5, 5]:\n    output = np.minimum(pow(abs(v_delta) * f + 0.75, -4), 1)\n    plt.plot(v_delta, output, label=f'slope={f}')\nplt.legend()\nplt.xlabel('$v_\\\\Delta^+$')\nplt.ylabel('Reflection Coefficient')\nplt.grid()\n\n\n\n\n\nAs \\(Slope\\) goes up, the region of the table where the reflection coefficient is 1 gets smaller. This plateau represents the moment where the bow and the string are “sticking” together.\nWe now need to find what is the usable range for \\(Slope\\). Looking at the STK again, we can see where the slope is set:\nbowed.cpp\n    bowTable_.setSlope( 5.0 - (4.0 * normalizedValue) );\nWhere normalizedValue is a value between 0 and 1 representing the bow pressure. This effectively restricts the slope value between 1 and 5. In other words, as the bow pressure increases, the ‘sticking’ zone of the bow table gets larger. We can plot the bow table equation again, but this time with varying force values between 0 and 10 to understand why.\n\n\nCode\nv_delta = np.linspace(-1, 1, 50)\nf_bow = np.linspace(0, 10, 50)\n\nv_delta, f_bow = np.meshgrid(v_delta, f_bow)\noutput = np.minimum(pow(abs(v_delta) * f_bow + 0.75, -4), 1)\n\nfig, ax = plt.subplots()\nsurf = ax.pcolormesh(\n    f_bow,\n    v_delta,\n    output,\n    linewidth=0,\n    cmap='viridis',)\n\nfig.colorbar(surf, shrink=0.5, aspect=5, label='Reflection Coefficient')\n\nax.yaxis.set_major_formatter('{x:.02f}')\nax.xaxis.set_major_locator(MultipleLocator(1))\nax.set_xlabel('$Slope$')\nax.set_ylabel('$v_\\\\Delta^+$')\nax.dist = 10\n\n\n\n\n\nLooking at the graph, we can immediately see that once the slope gets higher than 5, the reflection coefficient returned by the table stays consistent and there’s limited value for a bow table to support a slope value higher than 5. On the other hand, with a slope value \\(&lt;1\\), the table becomes almost flat."
  },
  {
    "objectID": "posts/bowed_string/waveguide.html",
    "href": "posts/bowed_string/waveguide.html",
    "title": "BowedString Part 1: Digital Waveguide",
    "section": "",
    "text": "In this series, I will walk through the process of building a bowed string model using a digital waveguide. If you are not familiar with the technique, Julius O. Smith wrote a great book on the subject: Physical Audio Signal Processing. The particular model I will build can also be found in this book here.\n\n\n\nBowed string model by Julius O. Smith\n\n\nOne possible way to implement this model would be to implement it exactly as presented using 4 distinct delay lines. This would work quite well for a static model, but since we want to be able to change the delay lines’ lengths in real-time, we will quickly run into some issues.\nTo understand, let’s look at a basic delay line implementation. The canonical delay line usually consists of a circular buffer and two pointers: one for reading and one for writing. Changing the delay length is as simple as changing the read pointer’s position. This looks something like this:\n\n\n\nA delay line. The read pointer moves to the left as the delay length is decreased and to the right as the delay length is increased.\n\n\nWhen the length of a delay line is changed in real time, it is called a variable delay line. It is also possible to read in between two sample points by doing an interpolated read. This would make the delay line a fractional delay line. Being able to read in between samples is important as it will allow us to smoothly change the delay length in real-time.\nA simple waveguide can be implemented using two delay lines, one for the right traveling wave and one for the left traveling wave.\n\n\n\nA simple waveguide\n\n\nNotice how the delay lines are going in opposite directions. Now, if we were to change the waveguide length by reducing both delay line lengths this would look like this:\n\n\n\nReducing the waveguide length. The red parts indicate the samples that get discarded as the delay is decreased.\n\n\nIf the waveguide was modeling a string, we’ve now effectively removed a bit of the right traveling signal from the right end of the string and a bit of the left traveling signal from the left end of the string. This is physically impossible and can introduce discontinuities in the signal. Instead, what we want to achieve is something like this:\n\n\n\nA more realistic waveguide.\n\n\nNotice how the size of the waveguide does not change and instead, a reflection point is introduced at some point on the string, effectively splitting the waveguide in two. This is attempting to simulate a finger pressing on the string.\nOn top of being able to read at an arbitrary fractional point on the delay line, we will also need to be able to write into the delay line at a fractional point. To do this, we can use an algorithm presented in Vesa Välimäki’s paper Discrete-Time Modeling of Acoustic Tubes Using Fractional Delay Filters. While Välimäki is describing a way to implement a scattering junction, we can use the same system to implement our reflection point by changing some of the coefficient. Instead of using an allpass filter to interpolate the signal I have opted to use a simple linear interpolator. Since we want to be able to vary the position of the junction in real-time, we would need to perform extra work to avoid the transient that would be introduced by using an allpass interpolation. A method to eliminate these transients is presented in this paper by Vesa Välimäki, Timo I. Laakso and Jonathan MacKenzie. A C++ implementation can be found in libdsp.\n\n\n\nBlock diagram of the scattering junction by Vesa Välimäki\n\n\n\n\n\nBlock diagram of the waveguide gate. The allpass interpolator were change to linear interpolator and the coefficient were changed to conserve energy through the system.\n\n\nThe resulting system is what we will now call a waveguide gate. The coefficients ‘r’ is what I will call the gate coefficient. With a value of 1, the gate is fully closed and all the energy is reflected. With a value of 0, the gate is fully open and all the energy is transmitted. With a value between 0 and 1, the gate is partially open and some of the energy is reflected and some is transmitted.\nHere it is in action when the gate coefficient is set to 1:\n\n\n\nWaveguide gate with coefficient 1\n\n\nBy setting the gate coefficient to &lt; 1, we can simulate a light press on the string which can result in harmonics based on the position of the gate:\n\n\n\nWaveguide gate with coefficient 0.5 at the midpoint of the string\n\n\n\n\n\nWaveguide gate with coefficient 0.5 at the 1/4 of the string\n\n\nHere are some audio examples of the gate in action using a waveguide with 200 samples of delay and a gate positioned in the middle of the string. A triangle pluck is used to excite the string.\nGate coefficient = 0 (open string):\n\n\n\n\n\nGate coefficient = 1 (full press):\n\n\n\n\n\nGate coefficient = 0.005 (The fundamental quickly morphs into the first harmonic):"
  },
  {
    "objectID": "posts/windowed_sinc/windowed_sinc.html",
    "href": "posts/windowed_sinc/windowed_sinc.html",
    "title": "Windowed sinc resampling",
    "section": "",
    "text": "While there is a lot of theoritical explanation of the sinc resampling algorithm on the internet, there is unfortunately not a lot of simple practical examples as the implementation are usually heavily optimized and designed to support real-time scenario. This article will try to provide a simple implementation of the algorithm based on the CCRMA description article. You can find a plain Python script containing the code used in this article here.\nFirst, let’s get our python imports out of the way.\n\n\nShow the code\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.special import sinc\nfrom scipy.signal.windows import kaiser\nfrom scipy import signal\nfrom math import ceil\n\n\nLet’s define a function that will build our sinc table for us. The sinc table will only contain the “right-wing” of the symmetric FIR filter. This function will also return a table of differences between successive FIR samples which will be useful to speed up our linear interpolation later on.\n\ndef build_sinc_table(num_zeros, samples_per_crossing):\n\n    SINC_SIZE_ = num_zeros * samples_per_crossing\n    KAISER_BETA = 10\n\n    x = np.linspace(-num_zeros, num_zeros, SINC_SIZE_ * 2 + 1)\n    y = sinc(x)\n\n    window = kaiser(len(y), KAISER_BETA)\n\n    y = np.multiply(y, window)\n\n    h = y[SINC_SIZE_:]\n\n    h_diff = np.subtract(h[1:], h[:-1])\n    h_diff = np.append(h_diff, 0)\n\n    return h, h_diff\n\nAnd here’s what our table looks like:\n\n\nShow the code\nh, h_diff = build_sinc_table(num_zeros=13, samples_per_crossing=512)\nplt.figure(1)\nplt.plot(h)\nplt.grid()\n\n\n\n\n\nWe can now implement the main algorithm as described here.\n\ndef sinc_resample(x, ratio, h, h_diff, samples_per_crossing):\n    time_step = 1 / ratio\n    filter_scale = min(1, ratio)\n    filter_step = samples_per_crossing * filter_scale\n\n    output = np.ndarray(shape=ceil(len(x) * ratio))\n    out_idx = 0\n    t = 0\n    while t &lt; len(x):\n\n        acc = 0\n\n        integer_part = int(t)\n        fractional_part = t - integer_part\n\n        # Compute left wing\n        filter_offset = filter_step * fractional_part\n\n        left_coeff_count = int((len(h) - filter_offset) / filter_step)\n        left_coeff_count = min(integer_part, left_coeff_count) # avoid underflow access\n        for i in range(-left_coeff_count, 1):\n            filter_idx = filter_offset + filter_step * abs(i)\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + i] * weight\n\n        # compute right wing\n        fractional_part = 1 - fractional_part\n        filter_offset = filter_step * fractional_part\n\n        right_coeff_count = int((len(h) - filter_offset) / filter_step)\n        right_coeff_count = min(len(x) - integer_part - 1, right_coeff_count) # avoid overflow access\n        for i in range(0, right_coeff_count):\n            filter_idx = filter_offset + filter_step * i\n            fraction = filter_idx - int(filter_idx)\n            filter_idx = int(filter_idx)\n\n            weight = h[filter_idx] + fraction * h_diff[filter_idx]\n            acc += x[integer_part + 1 + i] * weight\n\n        if out_idx &lt; len(output):\n            output[out_idx] = acc\n            out_idx += 1\n        t += time_step\n\n    return output\n\nHere’s an example of the implementation at work where we will upsample a simple sine wave. The blue dotted line on the graph effectively shows what we would have obtained using a linear interpolation method instead.\n\n# Number of zeros crossing\nNZ = 13\n\n# Number of samples per zero crossing.\n# Higher sample count means better precision for our interpolation at the cost of more memory usage.\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(NZ, SAMPLES_PER_CROSSING)\n\nORIGINAL_FS = 100\nSIGNAL_FREQUENCY = 20\nTARGET_FS = 1000\n\ntime = np.linspace(0, 1, ORIGINAL_FS, endpoint=False)\nin_sine = np.sin(2 * np.pi * time * SIGNAL_FREQUENCY)\n\noutput = sinc_resample(in_sine, TARGET_FS / ORIGINAL_FS, h, h_diff, SAMPLES_PER_CROSSING)\nout_time = np.linspace(0, 1, TARGET_FS)\nplt.plot(out_time, output, 'g', label=\"Resampled output\")\nplt.plot(time, in_sine, 'b+:', label=\"Original signal\")\nplt.xlim(0.2, 0.4)\nplt.ylim(-1.1, 1.1)\nplt.grid()\nplt.legend(loc=\"upper right\")\nplt.show()\n\n\n\n\nWe are now ready to perform our benchmark test. Inspired by the Infinite Wave methodology, we will try to downsample a quadratic chirp signal from 96kHz to 44.1kHz.\n\nORIGINAL_FS = 96000\nCHIRP_LENGTH_SECONDS = 8\nEND_CHIRP_FREQUENCY = 44000\n\ntime = np.linspace(0, CHIRP_LENGTH_SECONDS, ORIGINAL_FS*CHIRP_LENGTH_SECONDS)\nin_chirp = signal.chirp(time, 0, CHIRP_LENGTH_SECONDS, END_CHIRP_FREQUENCY, 'quadratic') * 0.6\n\nWe will now resample that signal in 3 different ways. First, we’ll use our sinc_resample method with a sinc table containing 13 zero crossings and then again with a table containing 32 zero crossings. This should allow us to see how the number of zero crossing in our table affects the lowpass filtering of our implementation. Lastly, we will use numpy to resample the signal using linear interpolation so that we can compare our algorithm against a fast common resampling method.\n\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 128\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_sinc_1 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_sinc_2 = sinc_resample(\n    in_chirp,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nout_time = np.linspace(0, CHIRP_LENGTH_SECONDS, TARGET_FS*CHIRP_LENGTH_SECONDS)\nout_linear = np.interp(out_time, time, in_chirp)\n\ndef plot_spectrogram(title, w, fs, ax = None):\n    if ax is None:\n        fig, ax = plt.subplots()\n    plt.specgram(w, Fs=fs, mode='magnitude')\n    ax.set_title(title)\n    ax.set_xlabel('t (sec)')\n    ax.set_ylabel('Frequency (Hz)')\n    ax.set_ylim(0, ORIGINAL_FS/2)\n    ax.grid(True)\n\nfig = plt.figure(1)\nax1 = plt.subplot(221)\nplot_spectrogram(f\"Original {ORIGINAL_FS} Hz\", in_chirp, ORIGINAL_FS, ax1)\nax2 = plt.subplot(222)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_1} zeros\", out_sinc_1, TARGET_FS, ax2)\nax2 = plt.subplot(223)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz, {nz_2} zeros\", out_sinc_2, TARGET_FS, ax2)\nax3 = plt.subplot(224)\nplot_spectrogram(f\"Resampled to {TARGET_FS} Hz (numpy.interp)\", out_linear, TARGET_FS, ax3)\nfig.tight_layout(pad=1.0)\nplt.show()\n\n/Library/Frameworks/Python.framework/Versions/3.11/lib/python3.11/site-packages/matplotlib/axes/_axes.py:7775: RuntimeWarning: divide by zero encountered in log10\n  Z = 20. * np.log10(spec)\n\n\n\n\n\nFirst, we can immediately notice that the resampled output lost all content above the Nyquist frequency. This explains why half the spectrogram is empty. The downward line(s) around the 6-second mark is the higher frequency content present in the original file that is now folding around Nyquist. This is called aliasing. We can also see how the resampling done with 32 zeros shows slightly less aliasing than the 13 zeros resampling.\nFinally, we can look at the impulse and frequency response of our resampler:\n\n\nShow the code\nORIGINAL_FS = 96000\nTARGET_FS = 44100\nRESAMPLING_RATIO = TARGET_FS / ORIGINAL_FS\n\nIMPULSE_LENGTH = 128\nimpulse = np.zeros(IMPULSE_LENGTH)\nimpulse[round(IMPULSE_LENGTH/2)] = 1\n\nnz_1 = 13\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_1, SAMPLES_PER_CROSSING)\n\nout_imp_1 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nnz_2 = 32\nSAMPLES_PER_CROSSING = 512\nh, h_diff = build_sinc_table(nz_2, SAMPLES_PER_CROSSING)\n\nout_imp_2 = sinc_resample(\n    impulse,\n    RESAMPLING_RATIO,\n    h,\n    h_diff,\n    SAMPLES_PER_CROSSING)\n\nfig = plt.figure(2)\nfig.set_figwidth(10)\nplt.subplot(211)\nplt.plot(out_imp_1)\n\nplt.subplot(212)\nplt.plot(out_imp_2)\n\n\n\n\n\n\n\nShow the code\nfrom scipy import fft\n\nNFFT = 1024\nimpulse_fft = fft.fft(out_imp_1, NFFT)\nimpulse_fft = fft.fftshift(impulse_fft)\n\nfft_db = 20 * np.log10(np.abs(impulse_fft))\nxf = fft.fftfreq(NFFT, 1/TARGET_FS)\nxf = fft.fftshift(xf)\nplt.figure(3)\nplt.plot(xf, fft_db)\nplt.xlim(0, TARGET_FS)\nplt.grid()\n\n# Ideal filter\nideal_x = np.zeros(22000)\nideal_x[-1] = -10\nplt.plot(ideal_x)"
  },
  {
    "objectID": "posts/bowed_string/bowed_string_example.html",
    "href": "posts/bowed_string/bowed_string_example.html",
    "title": "BowedString Part 3: BowedString audio example",
    "section": "",
    "text": "Here are a few audio examples of the BowedString instrument in its current state. As a reminder, what we have right now is a digital waveguide with a nut and bridge. The bridge has a slight low-pass filter. The string is excited by the bow model we discussed in part 2.\nIf these sound cold and robotic, that is to be expected. The body filter is missing and all of these samples were generated by C++ code with all of the parameters moving in a perfectly linear way. It is helpful to have simple and easily reproducible sounds to test the code with and will make debugging and tuning the instrument much easier.\n\nVelocity and Force sweep from 0 to 1 then back to 0.\n\n\n\n\n\n\n\n\nFast bowing by modulating velocity with a clipped sine wave. A staccato sound can be achieved by reducing the amount of clipping.\n\n\n\n\n\n\n\n\nVibrato. The length of the string is modulated by a sine wave.\n\n\n\n\n\n\n\n\nPitch slide, 440Hz to 660Hz."
  },
  {
    "objectID": "posts/phaseshaper/phaseshaper.html",
    "href": "posts/phaseshaper/phaseshaper.html",
    "title": "Phaseshaping Oscillator",
    "section": "",
    "text": "Phaseshaper is a eurorack oscillator built on the Daisy Patch. The module implements 7 phaseshaping techniques as presented in Phaseshaping Oscillator Algorithms For Musical Sound Synthesis by Jari Kleimola, Victor Lazzarini, Joseph Timoney, and Vesa Välimäki. The C++ implementation of the phaseshaping algorithm was largely based on the original code in Python. Each phaseshaping technique can also be modulated, as described in the paper. The module also allows the possibility to crossfade between each waveform, providing an even wider range of timbres.\nHere you can find captures of the different waveforms and how they respond to modulation.\n\n\n\n\nHardsync\n\n\n\n\n\nSupersaw\n\n\n\n\n\nSoftsync\n\n\n\n\n\nWaveslice\n\n\n\n\n\n\nVariable-slope: Ramp Phase\n\n\n\n\n\nVariable-slope: Triangular Phase\n\n\n\n\n\nTriangle Modulation\n\n\n\n\n\nAnd here’s some audio samples of the different waveforms:\n\n\nSupersaw\n\n\n\n\n\n\n\nVariable-slope, Triangular phase\n\n\n\n\n\n\n\nVariable-slope, Ramp phase\n\n\n\n\n\n\n\nWaveslice\n\n\n\n\n\n\n\nSoftsync"
  }
]