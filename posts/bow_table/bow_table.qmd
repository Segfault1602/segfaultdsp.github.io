---
title: "Bow Table"
author: Alexandre St-Onge
date: '2023-09-16'
jupyter: python3
---

Let's take a look at the bow table as defined in the [stk](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/include/BowTable.h#L84):

$$ BowTable(v_\Delta^+) = \min \left \{(|v_\Delta^+|*f_{bow} + 0.75)^{-4}, 1 \right \} $$

Where $v_\Delta^+$ is the velocity of the bow minus the velocity of the string going into the bow and $f_{bow}$ is the bow force. While the equation may seem daunting at first, we can easily plot it and immediatly recognize a shape similar to the linear bow table as presented by figure [9.54](https://ccrma.stanford.edu/~jos/pasp/Bow_String_Scattering_Junction.html) in Physical Audio Signal Processing by Julius O. Smith.

```{python}
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import MultipleLocator

v_delta = np.linspace(-1, 1, 50)
bow_force = 4

output = np.minimum(pow(abs(v_delta) * bow_force + 0.75, -4), 1)

plt.figure(1)
plt.plot(v_delta, output)
plt.grid()

```

We can now observe how varying the force transform bow table.

```{python}

v_delta = np.linspace(-1, 1, 100)

plt.figure(2)
for f in [1, 2.5, 5]:
    output = np.minimum(pow(abs(v_delta) * f + 0.75, -4), 1)
    plt.plot(v_delta, output, label=f'force={f}')
plt.legend()
plt.grid()
```

See how as the "force" goes up, the region of the table where the reflection coefficient is 1 gets smaller. This is simply a quirk of the equation we are using as in reality, the more force is applied, the easier it will be for the string and bow to stick toghether. It is common to control parameter like these by assigning a value going from 0 to 1, which make this a little bit counterintuitive, but this is something that we will address later.

For now, let's try to find a usable range of value for $f_{bow}$. To do so we can plot the same graph as before and adding $f_{bow}$ as a variable.

```{python}

v_delta = np.linspace(-1, 1, 50)
f_bow = np.linspace(0, 10, 50)

v_delta, f_bow = np.meshgrid(v_delta, f_bow)
output = np.minimum(pow(abs(v_delta) * f_bow + 0.75, -4), 1)

fig, ax = plt.subplots()
surf = ax.pcolormesh(
    f_bow,
    v_delta,
    output,
    linewidth=0,
    cmap='viridis',)

fig.colorbar(surf, shrink=0.5, aspect=5)

ax.yaxis.set_major_formatter('{x:.02f}')
ax.xaxis.set_major_locator(MultipleLocator(1))
ax.set_xlabel('Bow Force')
ax.set_ylabel('v_delta')
ax.dist = 10
```

Looking at the graph, we can immediatly see that once the bow force gets higher than 5, the reflection coefficient returned by the table stays consistent and there's limited value for a bow table to support force value higher than 5. On the other hand, with a bow force value near 0, the table will always return a reflection coefficient of 1. From this, we can conclude that we will probably want to limit our bow force value between 1 and 5. And if we look at [bowed.cpp](https://github.com/thestk/stk/blob/d0345712db51a01d8d6ca44980c56798a54b0fc3/src/Bowed.cpp#L155) we can see this equation:

```{c++}
    bowTable_.setSlope( 5.0 - (4.0 * normalizedValue) );
```

Where `normalizedValue` is a value between 0 and 1. This equation solves our two problems:
1. It limits the bow force value between 1 and 5
2. An increasing `normalizedValue` now correspond to a higher bow force.